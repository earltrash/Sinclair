#include "Scene_End.h"
#include "Object.h"
#include "ButtonComponent.h"
#include "BackgroundComponent.h"
#include "MouseListenerComponent.h"
#include "SceneManager.h"
#include "ResourceManager.h"
#include "Renderer.h"
#include "UIManager.h"
#include "GameManager_2.h"


Scene_End::Scene_End(string name)
{
	m_name = name;
}

Scene_End::~Scene_End()
{

}

void Scene_End::Initalize()
{
	if (dirty) return; // 이미 초기화되었으면 스킵
	CreateObj(); // 오브젝트 생성 (한 번만)
	dirty = true;
	for (const auto& [Name, obj] : m_gameObjects)
	{
		UIManager::Get().AddSceneObject(obj); // 1011 1. 일단 id를 받아야 함 2. 노래를 위한 id 변환
	}


	int id = GameManager::Get().arrEndingID[GameManager::Get().GetCurrentGen() - 2];
	PlayEDM(id);

	

	//id를 받고 엔딩에 맞는 사운드가 나와야 함. id -> index -> vector = channel 식으로 


}

void Scene_End::Enter()
{
	ebm = GameManager::Get().AftAdv();


	m_fadeStarted = true;
	m_currentTime = 0.f;

	Initalize();

	int gen = GameManager::Get().curGen;
	int targetID = GameManager::Get().arrEndingID[gen - 2];
	auto& EndingVector = ResourceManager::Get().Get_TextBank().EndingVector;
	auto it = std::find_if(EndingVector.begin(), EndingVector.end(),
		[targetID](const TextBank::Ending& e) {
			return e.ID == targetID;
		});


	if (it != EndingVector.end())
	{
		job = StrToWstr(it->job);
	}
	else
	{
		job = L"없는뎁숑";
	}
	if (it != EndingVector.end())
	{
		auto txt = ResourceManager::Get().Get_TextBank().replaceGeneration(it->endingText, gen);
		text = StrToWstr(txt);
	}
	else
	{
		text = L"없는뎁숑";
	}
}

void Scene_End::Exit()
{
	Clean();

	m_image1Opacity = 0.f;
	m_image2Opacity = 0.f;
	m_image3Opacity = 0.f;
	after_fadeStarted = false;
	m_fadeStarted = false;
	m_isTransitioning = false;
}

void Scene_End::Clean()
{
	if (!dirty) return;

	UIManager::Get().ClearSceneObjects();
	m_gameObjects.clear();
	
	dirty = false;
}

void Scene_End::Update()
{
	// 씬 전환 지연 처리
	if (m_isTransitioning && !m_nextScene.empty())
	{
		m_currentDelay += 0.016f;
		if (m_currentDelay >= m_transitionDelay)
		{
			SceneManager::Get().ChangeScene(m_nextScene);
			m_nextScene = "";
			m_currentDelay = 0.0f;


		}
	}

	if (m_fadeStarted)
	{
		m_currentTime += 0.016f;

		// 첫 번째 이미지: 0초~1.5초 페이드인, 3초~4.5초 페이드아웃
		if (m_currentTime <= m_fadeDuration)
		{
			m_image1Opacity = std::clamp(m_currentTime / m_fadeDuration, 0.f, 1.f);
		}

		// 두 번째 이미지: 0.5초~2초 페이드인, 3.5초~5초 페이드아웃  
		if (m_currentTime >= m_intervalTime && m_currentTime <= m_intervalTime + m_fadeDuration)
		{
			m_image2Opacity = std::clamp((m_currentTime - m_intervalTime) / m_fadeDuration, 0.f, 1.f);
		}

		// 세 번째 이미지: 1초~2.5초 페이드인, 4초~5.5초 페이드아웃
		if (m_currentTime >= m_intervalTime * 2 && m_currentTime <= m_intervalTime * 2 + m_fadeDuration)
		{
			m_image3Opacity = std::clamp((m_currentTime - m_intervalTime * 2) / m_fadeDuration, 0.f, 1.f);
		}

		// 모든 페이드 완료 체크
		if (m_currentTime >= 5.5f)
		{
			m_fadeStarted = false;
			m_gameObjects["스킵버튼"]->GetComponent<ButtonComponent>()->SetCurrentBitmap("스킵");
			after_fadeStarted = true;
		}
	}


}

void Scene_End::LogicUpdate(float delta)
{


}


void Scene_End::Render()
{

	for (const auto& [Name, obj] : m_gameObjects)
	{
		D2DRenderer::Get().DrawBitmap(obj->GetRenderInfo()->GetRenderInfo());
	}

	if (ebm.size() == 1)
	{
		// 하나만 있을 때 → 그냥 렌더
		const auto& [Name, obj] = *ebm.begin();
		D2D1_RECT_F rect{ 17, 22, 1024 + 17, 1024 +22 };
		D2D1_RECT_F srcRect{ 0, 0, 1024 , 1024 };
		D2DRenderer::Get().DrawBitmap(obj.Get(), rect, srcRect, m_image1Opacity);
	}
	else if (ebm.size() == 2)
	{
		// 두 개 있을 때 → good/bad 구분
		for (const auto& [Name, obj] : ebm) // -> 임시로 하고 일단 
		{
			D2D1_RECT_F rect{ 17, 22, 1024 + 17, 1024 + 22 };
			D2D1_RECT_F srcRect{ 0, 0, 1024 , 1024 };

			if (Name.find("_good") != std::string::npos)
			{
				// good일 때 처리
				D2DRenderer::Get().DrawBitmap(obj.Get(), rect, srcRect, m_image1Opacity);

			}
			else if (Name.find("_bad") != std::string::npos)
			{
				// bad일 때 처리
				D2DRenderer::Get().DrawBitmap(obj.Get(), rect, srcRect, m_image1Opacity);
			}
			else
			{
				// 예상 외의 이름이면 경고
				std::cerr << "[WARN] good/bad 구분 불가: " << Name << std::endl;
			}
		}
	}

	D2DRenderer::Get().CreateWriteResource(L"빛의 계승자 Bold", DWRITE_FONT_WEIGHT_BOLD, 90.0f);
	// 벡터로 순회해서 찾기



	D2DRenderer::Get().DrawMessageCenter(job.c_str(),
		1080.f, 120.f, 1920.f - 1080.f, 255.f - 120.f, D2D1::ColorF::White, m_image3Opacity);
	

	D2DRenderer::Get().CreateWriteResource(L"빛의 계승자 Bold", DWRITE_FONT_WEIGHT_BOLD, 30.0f);
	

	D2DRenderer::Get().DrawMessageCenter(text.c_str(),
		1223.f, 255.f, 564.f, 1080.f - 255.f, D2D1::ColorF::White, m_image2Opacity);
	
}

void Scene_End::CreateObj()
{
	//////////////////////
	// 투명 이미지 갖고 오기
	auto transparentImg = ResourceManager::Get().GetTexture("transparent");

	//////////////////////
	//////////////////////
	//////////////////////
	// [1] 좌측 창

	// 1. 이미지 갖고 오기
	auto 엔딩1 = ResourceManager::Get().GetTexture("엔딩", "01");
	// 2. 오브젝트 만들기
	auto 좌측창 = std::make_unique<Object>();
	//좌측창->SetPosition(Vec2(-20, -16));
	좌측창->SetPosition(Vec2(0, 0));

	// 3.0. 랜더 인포 컴포넌트
	auto 좌측창info = 좌측창->GetRenderInfo();
	좌측창info->SetBitmap(엔딩1.Get());
	// 3. 배경 컴포넌트 만들기
	auto 좌측창Comp = 좌측창->AddComponent<BackgroundComponent>(좌측창info);
	좌측창Comp->SetWidth(1098);
	좌측창Comp->SetHeight(1080);
	좌측창Comp->BitmapPush("좌측창", 엔딩1);
	좌측창Comp->SetCurrentBitmap("좌측창");

	/// 9
	m_gameObjects.emplace("aa좌측창", std::move(좌측창));

	//////////////////////
	//////////////////////
	//////////////////////
	// [2] 이미지
	// 랜더로 뺌
	

	//////////////////////
	//////////////////////
	//////////////////////
	// [3] 우측 창

	// 1. 이미지 갖고 오기
	auto 엔딩3 = ResourceManager::Get().GetTexture("엔딩", "03");
	// 2. 오브젝트 만들기
	auto 우측창 = std::make_unique<Object>();
	우측창->SetPosition(Vec2(1080, 0));

	auto 우측창info = 우측창->GetRenderInfo();
	우측창info->SetBitmap(엔딩3.Get());
	// 3. 배경 컴포넌트 만들기
	auto 우측창Comp = 우측창->AddComponent<BackgroundComponent>(우측창info);
	우측창Comp->SetWidth(843);
	우측창Comp->SetHeight(1080);
	우측창Comp->BitmapPush("우측창", 엔딩3);
	우측창Comp->SetCurrentBitmap("우측창");

	/// 9
	m_gameObjects.emplace("a우측창", std::move(우측창));

	//////////////////////
	//////////////////////
	//////////////////////
	// [4] 스킵 버튼

	// 1. 이미지 갖고 오기
	auto 엔딩4 = ResourceManager::Get().GetTexture("엔딩", "04");
	// 2. 오브젝트 만들기
	auto 스킵버튼 = std::make_unique<Object>();
	스킵버튼->SetPosition(Vec2(1827, 960));

	auto 스킵버튼info = 스킵버튼->GetRenderInfo();
	스킵버튼info->SetBitmap(엔딩4.Get());

	// 3. 버튼 컴포넌트 만들기
	auto 스킵컴포넌트 = 스킵버튼->AddComponent<ButtonComponent>(스킵버튼info);
	스킵컴포넌트->SetWidth(엔딩4->GetSize().width);
	스킵컴포넌트->SetHeight(엔딩4->GetSize().height);

	// 4. 버튼 비트맵 설정
	스킵컴포넌트->BitmapPush("스킵", 엔딩4);
	스킵컴포넌트->BitmapPush("transparent", transparentImg);
	스킵컴포넌트->SetCurrentBitmap("transparent");

	// 5. 마우스 리스너 컴포넌트 (버튼 컴포넌트를 캡처로 전달)
	auto 스킵리스너 = 스킵버튼->AddComponent<MouseListenerComponent>(
		[스킵컴포넌트, this](const MSG& msg) {
			if(after_fadeStarted)
			{
				스킵컴포넌트->CheckCollision(msg);
				스킵컴포넌트->Worked(msg);
			}
		}
	);

	스킵컴포넌트->SetOnClickCallback([this]() {
		
		if (m_isTransitioning)
		{
			return;
		}

		std::cout << "스킵 버튼 클릭됨" << std::endl;
		// 엔딩 스킵 로직 추가
		
		int temp = GameManager::Get().curGen;

		if (temp == 4)
		{
			temp = 2;
			SafeChangeScene("History" , temp);

			SoundManager::Instance().PauseBGM(cur_EDM_ID, true);
		}
		else
		{
			temp++;
			SafeChangeScene("OutGame", temp);
			//SoundManager::Instance().PauseBGM(cur_EDM_ID, true);
			SoundManager::Instance().CrossfadeBGM(SoundManager::Instance().Get_Playing_Key(), "OutGame", 2.5f);

			Inventory* statwin = dynamic_cast<Inventory*>(UIManager::
				Get().GetWindow(UIWindowType::InventoryWindow));

			if (statwin != nullptr)
			{
				statwin->LoadItemDatabase(static_cast<Need_Moment>(temp - 2)); //-> 언제 필요하냐?	
			}

		}

		});

	/// 9
	m_gameObjects.emplace("스킵버튼", std::move(스킵버튼));


	//////////////////////
	//////////////////////
	//////////////////////
	// [6] 바

	// 1. 이미지 갖고 오기
	auto 엔딩6 = ResourceManager::Get().GetTexture("엔딩", "06");
	// 2. 오브젝트 만들기
	auto 바 = std::make_unique<Object>();
	바->SetPosition(Vec2(1223, 255));

	auto 바info = 바->GetRenderInfo();
	바info->SetBitmap(엔딩6.Get());
	// 3. 배경 컴포넌트 만들기
	auto 바Comp = 바->AddComponent<BackgroundComponent>(바info);
	바Comp->SetWidth(엔딩6->GetSize().width);
	바Comp->SetHeight(엔딩6->GetSize().height);
	바Comp->BitmapPush("바", 엔딩6);
	바Comp->SetCurrentBitmap("바");

	/// 9
	m_gameObjects.emplace("바", std::move(바));

}

void Scene_End::PlayEDM(int id)
{
	//string sid = to_string(id);

	string idStr = to_string(id); // "1011"
	string first3 = idStr.substr(0, 3); // "101"

	string EDMID = first3 + "1";

	SoundManager::Instance().PlayBGM(EDMID, false);

	cur_EDM_ID = EDMID;

}

void Scene_End::SafeChangeScene(const std::string& sceneName, int gen)
{
	if (!m_isTransitioning)
	{
		m_isTransitioning = true;
		m_nextScene = sceneName;
		m_currentDelay = 0.0f;

		GameManager::Get().curGen = gen;

		// 디버그 로그
		std::cout << "씬 전환 예약: " << sceneName << std::endl;
	}
}
