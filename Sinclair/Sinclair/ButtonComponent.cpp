#include "ButtonComponent.h"
#include "ResourceManager.h"
#include "MouseListenerComponent.h"

void ButtonComponent::BitmapPush(string NM, ComPtr<ID2D1Bitmap1> Bitmap)
{
	m_Bitmap.emplace(NM, Bitmap);
}

ComPtr<ID2D1Bitmap1> ButtonComponent::GetBitmap()
{
    if (m_isInvisible)
    {
        return nullptr;
    }

    string key;
    switch (m_currentState)
    {
    case ButtonState::Normal:   key = "normal";  m_opacity = 1.0f; break;
    case ButtonState::Hover:    key = "hover";   m_opacity = 0.5f; break;
    case ButtonState::Pressed:  key = "pressed"; m_opacity = 0.0f; break;
    case ButtonState::Disabled: key = "disabled";m_opacity = 0.0f; break;
    default: key = "normal"; break;
    }

    auto it = m_Bitmap.find(key);
    if (it != m_Bitmap.end())
        return it->second;

    return nullptr;
}


void ButtonComponent::Worked(const MSG& msg)
{

    POINT CORD = { GET_X_LPARAM(msg.lParam), GET_Y_LPARAM(msg.lParam) };
    Vec2 pos = m_Owner->GetTransform().GetPosition();
    

    // 투명 버튼인 경우 설정된 크기 사용
    if (m_isInvisible)
    {
        Rect rect(pos.x, pos.y, width, height);
        bool isInside = InRect(rect, CORD);

        if (isInside)
        {
            if (msg.message == WM_LBUTTONDOWN)
            {
                SetState(ButtonState::Pressed);
            }
            else if (msg.message == WM_LBUTTONUP && m_currentState == ButtonState::Pressed)
            {
                if (m_onClick) 
                {
                    m_onClick();
                    return;
                }
                SetState(ButtonState::Normal);
            }
            else if (msg.message == WM_MOUSEMOVE && m_currentState != ButtonState::Pressed)
            {
                SetState(ButtonState::Hover);
            }
        }
        else
        {
            SetState(ButtonState::Normal);
        }
        return;
    }

    // 투명버튼이 아닌데 비트맵이 설정되지 않았다면 리턴
    if (!GetBitmap()) return;

    // 현재 상태에 맞는 비트맵 크기 사용
    auto currentBitmap = GetBitmap();
    D2D1_SIZE_F size = currentBitmap->GetSize();
    Rect rect(pos.x, pos.y, size.width, size.height);

    bool wasInside = (m_currentState == ButtonState::Hover || m_currentState == ButtonState::Pressed);
    bool isInside = InRect(rect, CORD);

    if (isInside)
    {
        if (msg.message == WM_LBUTTONDOWN)
        {
            SetState(ButtonState::Pressed);
            // 클릭 이벤트는 마우스 버튼을 뗄 때 발생시키는 것이 일반적
        }
        else if (msg.message == WM_LBUTTONUP && m_currentState == ButtonState::Pressed)
        {
            // 버튼이 눌린 상태에서 마우스를 뗐을 때만 클릭으로 처리
            if (m_onClick) m_onClick();

            SetState(ButtonState::Hover);
        }
        else if (msg.message == WM_MOUSEMOVE && m_currentState != ButtonState::Pressed)
        {
            SetState(ButtonState::Hover);
        }
    }
    else
    {
        // 마우스가 버튼 범위를 벗어났을 때
        if (wasInside)
        {
            SetState(ButtonState::Normal);
        }
    }
}

void ButtonComponent::SetInvisibleButton(int width, int height)
{
    m_isInvisible = true;
    SetWidth(width);
    SetHeight(height);
}

void ButtonComponent::SetCurrentBitmap(string Nm)
{
	m_curbm = m_Bitmap[Nm];
	//혹은 Find로 설정하는 게 필요하긴 함. 

    m_renderInfo->SetBitmap(m_curbm.Get());
}

