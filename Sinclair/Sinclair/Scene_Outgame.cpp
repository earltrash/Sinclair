#include "Scene_Outgame.h"
#include "Object.h"
#include "ButtonComponent.h"
#include "BackgroundComponent.h"
#include "MouseListenerComponent.h"
#include "SceneManager.h"
#include "ResourceManager.h"
#include "GameManager.h"
#include "Renderer.h"

// 랜덤
#include <random>
#include <iterator>

Scene_Outgame::Scene_Outgame(string name)
{
		m_name = name;
}

Scene_Outgame::~Scene_Outgame()
{
	Clean();
}

void Scene_Outgame::Initalize()
{
	if (dirty) return;  

	CreateObj();  
	dirty = true;
}

void Scene_Outgame::Clean()
{
		m_gameObjects.clear();
	dirty = false;
}

void Scene_Outgame::Update()
{
}

void Scene_Outgame::LogicUpdate(float delta)
{
}

void Scene_Outgame::Enter()
{
		Initalize();
	SetupCharacterAndBackground();


	 if (GameManager::Get().WasInGame) {
		 m_state = State::CHOICE_MENU;
	 } else {
		 m_state = State::FIRST_ENTER;
		 GameManager::Get().WasInGame = true;
}


	// 우선 초기 상태로 진입
	ChangeState(m_state);
}

void Scene_Outgame::Exit()
{
		Clean();
}

void Scene_Outgame::Render()
{

	for (const auto& [Name, obj] : m_gameObjects)
	{
		D2DRenderer::Get().DrawBitmap(obj->GetRenderInfo()->GetRenderInfo());
	}




	D2DRenderer::Get().CreateWriteResource(L"빛의 계승자 Bold", DWRITE_FONT_WEIGHT_BOLD, 36.0f);
	std::wstring characterName = L"싱클레어 " + std::to_wstring(GameManager::Get().curGen) + L"세";
	D2DRenderer::Get().DrawMessage(characterName.c_str(), 481.74f, 828.38f, 1300.f, 1000.f, D2D1::ColorF::White);

	D2DRenderer::Get().CreateWriteResource(L"빛의 계승자 Regular", DWRITE_FONT_WEIGHT_NORMAL, 24.0f);
	// 상태에 따른 메인 텍스트 렌더링
	if (!curText.empty())
	{
		std::wstring wCurText = StrToWstr(curText);
		D2DRenderer::Get().DrawMessage(wCurText.c_str(), 768.21f, 828.38f, 1300.f, 1000.f, D2D1::ColorF::White);
	}

	D2DRenderer::Get().CreateWriteResource();

}

void Scene_Outgame::CreateObj()
{
	//////////////////////
	//////////////////////
	//////////////////////
	// [1] Background 

	// 1. 이미지 갖고 오기
	auto outGameBackground = ResourceManager::Get().GetTexture("아웃게임");
	// 2. 오브젝트 만들기
	auto Background = std::make_unique<Object>();
	Background->SetPosition(Vec2(0, 0));

	// 3.0. 랜더 인포 컴포넌트
	auto bgInfo = Background->GetRenderInfo();
	bgInfo->SetBitmap(outGameBackground.Get());

	// 3. 배경 컴포넌트 만들기
	auto bgComp = Background->AddComponent<BackgroundComponent>(bgInfo);
	// 3.1.1 사이즈 다르면 
	bgComp->SetWidth(1920); bgComp->SetHeight(1080);
	bgComp->BitmapPush("Background", outGameBackground);
	// 9. 게임 오브젝트들에 집어넣기
	m_gameObjects.emplace("Background", std::move(Background));



	//////////////////////
	//////////////////////
	//////////////////////
	// [2] 캐릭터 이미지 
	// 배경 컴포넌트라고 명명 했지만 -> 이미지 컴포넌트라고 바꿔야 해. 
	// 나는 여기다가 셰이더? 넣어야 된다고 생각해. 
	// 캐릭터에 올려 놓으면 바뀌어야지. -> 그럼 버튼 컴포넌트로 바꿔야 하는 거 아닌가?

	// 1. 이미지 갖고 오기
	auto Sinclair2 = ResourceManager::Get().GetTexture("싱클레어", "2세");
	auto Sinclair3 = ResourceManager::Get().GetTexture("싱클레어", "3세");
	auto Sinclair4 = ResourceManager::Get().GetTexture("싱클레어", "4세");
	// 2. 오브젝트 만들기
	auto Character = std::make_unique<Object>();
	Character->SetPosition(Vec2(0, 0));

	// 3.0. 랜더 인포 컴포넌트
	auto chInfo = Character->GetRenderInfo();
	chInfo->SetBitmap(Sinclair2.Get());
	// 3. 배경 컴포넌트 만들기
	auto chComp = Character->AddComponent<BackgroundComponent>(chInfo);

	// 3.1.1 사이즈 다르면 
	chComp->SetWidth(1920); chComp->SetHeight(1080);

	chComp->BitmapPush("Sinclair2", Sinclair2);
	chComp->BitmapPush("Sinclair3", Sinclair3);
	chComp->BitmapPush("Sinclair4", Sinclair4);
	// 9. 게임 오브젝트들에 집어넣기 
	m_gameObjects.emplace("Character", std::move(Character));
	

	//////////////////////
	//////////////////////
	//////////////////////
	// [3] 텍스트 창
	
	// 1. 이미지 갖고 오기
	auto 아웃게임1 = ResourceManager::Get().GetTexture("아웃게임", "01");
	// 2. 오브젝트 만들기
	auto 텍스트박스 = std::make_unique<Object>();
	     텍스트박스->SetPosition(Vec2(421, 766));

	// 3.0. 랜더 인포 컴포넌트
		 auto outgame1Info = 텍스트박스->GetRenderInfo();
		 outgame1Info->SetBitmap(아웃게임1.Get());
	// 3. 배경 컴포넌트 만들기
	auto 텍스트박스Comp = 텍스트박스->AddComponent<BackgroundComponent>(outgame1Info);
	
	// 3.1.1 사이즈 
	텍스트박스Comp->SetWidth(아웃게임1->GetSize().width);
	텍스트박스Comp->SetHeight(아웃게임1->GetSize().height);


	텍스트박스Comp->BitmapPush("아웃게임1", 아웃게임1);
	텍스트박스Comp->SetCurrentBitmap("아웃게임1");
	// 9. 게임 오브젝트들에 집어넣기 
	m_gameObjects.emplace("아웃게임1", std::move(텍스트박스));


	/////////////////////
	/////////////////////
	/////////////////////
	// [4] 예 버튼

	// 1. 이미지 갖고 오기
	auto 아웃게임4 = ResourceManager::Get().GetTexture("아웃게임", "04");
	// 2. 오브젝트 만들기
	auto 예 = std::make_unique<Object>();
	예->SetPosition(Vec2(1134, 905));

	auto 예info = 예->GetRenderInfo();
	예info->SetBitmap(아웃게임4.Get());
	// 3. 버튼 컴포넌트 만들기
	auto YesComp = 예->AddComponent<ButtonComponent>(예info);
	YesComp->SetWidth( 아웃게임4->GetSize().width);
	YesComp->SetHeight(아웃게임4->GetSize().height);

	//  4. 버튼 비트맵 설정
	// 투명도 기준이면 굳이 이렇게 할 필요 없긴 해. 
	YesComp->BitmapPush("yes",  아웃게임4);

	YesComp->SetCurrentBitmap("yes");

	// 5. 마우스 리스너 컴포넌트 (버튼 컴포넌트를 캡처로 전달)
	auto Yes_mouseListener = 예->AddComponent<MouseListenerComponent>(
		[YesComp](const MSG& msg) {
			YesComp->Worked(msg);
		}
	);

	YesComp->SetOnClickCallback([this]() {
		// 그렇게 하면 되는 구나
		//SceneManager::Get().ChangeScene("InGame");
		//std::cout << "SceneManager::Get().ChangeScene(\"InGame\");" << std::endl;
		});

	/// 9
	m_gameObjects.emplace("아웃게임4", std::move(예));


	/////////////////////
	/////////////////////
	/////////////////////
	// [5] 아니오 버튼/다음 버튼

	// 1. 이미지 갖고 오기
	auto 아웃게임5다음 = ResourceManager::Get().GetTexture("아웃게임", "05다음");
	auto 아웃게임5아니오 = ResourceManager::Get().GetTexture("아웃게임", "05아니오");

	// 2. 오브젝트 만들기
	auto 아니오 = std::make_unique<Object>();
	아니오->SetPosition(Vec2(1296, 906));

	auto 아니오info = 아니오->GetRenderInfo();
	아니오info->SetBitmap(아웃게임5다음.Get());

	// 3. 버튼 컴포넌트 만들기
	auto NoComp = 아니오->AddComponent<ButtonComponent>(아니오info);
	NoComp->SetWidth(아웃게임5아니오->GetSize().width);
	NoComp->SetHeight(아웃게임5아니오->GetSize().height);

	//  4. 버튼 비트맵 설정
	// 투명도 기준이면 굳이 이렇게 할 필요 없긴 해. 
	NoComp->BitmapPush("next", 아웃게임5다음);
	NoComp->BitmapPush("no", 아웃게임5아니오);

	//changeState()
	//NoComp->SetCurrentBitmap("no");

	// 5. 마우스 리스너 컴포넌트 (버튼 컴포넌트를 캡처로 전달)
	auto No_mouseListener = 아니오->AddComponent<MouseListenerComponent>(
		[NoComp](const MSG& msg) {
			NoComp->Worked(msg);
		}
	);

	NoComp->SetOnClickCallback([this]() {
			//changeState()
		});

	/// 9 
	m_gameObjects.emplace("아웃게임5", std::move(아니오));

	

	/////////////////////
	/////////////////////
	/////////////////////
	// [6] 뒤로가기 버튼

	// 1. 이미지 갖고 오기
	auto 뒤로가기 = ResourceManager::Get().GetTexture("뒤로가기");
	// 2. 오브젝트 만들기
	auto 뒤로 = std::make_unique<Object>();
	뒤로->SetPosition(Vec2(41, 31));

	auto 뒤로info = 뒤로->GetRenderInfo();
	뒤로info->SetBitmap(뒤로가기.Get());
	// 3. 버튼 컴포넌트 만들기
	auto backComp = 뒤로->AddComponent<ButtonComponent>(뒤로info);
	backComp->SetWidth(뒤로가기->GetSize().width); 
	backComp->SetHeight(뒤로가기->GetSize().height);
	
	//  4. 버튼 비트맵 설정
	// 투명도 기준이면 굳이 이렇게 할 필요 없긴 해. 
	backComp->BitmapPush("back", 뒤로가기);

	backComp->SetCurrentBitmap("back");

	// 5. 마우스 리스너 컴포넌트 (버튼 컴포넌트를 캡처로 전달)
	auto Back_mouseListener = 뒤로->AddComponent<MouseListenerComponent>(
		[backComp](const MSG& msg) {
			backComp->Worked(msg);
		}
	);

	backComp->SetOnClickCallback([this]() {
		std::cout << "버튼 클릭됨 - 현재 씬: " << typeid(*this).name() << std::endl;
		SceneManager::Get().ChangeScene("Title");
		//std::cout << "뒤로가기 (시작화면으로)" << std::endl;
		});

	/// 9
	m_gameObjects.emplace("뒤로가기", std::move(뒤로));





}

std::string Scene_Outgame::getRandomText()
{
	auto range = outGameTextTable.equal_range(m_state);

	if (range.first == range.second) {
		return "텍스트 없음"; // ID가 없는 경우
	}

	// 해당 ID의 모든 텍스트를 벡터로 복사
	std::vector<std::string> texts;
	for (auto it = range.first; it != range.second; ++it) {
		texts.push_back(it->second);
	}

	// 랜덤 선택
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<> dist(0, texts.size() - 1);

	return texts[dist(gen)];
}

void Scene_Outgame::SetupCharacterAndBackground()
{	
	// 배경은 안바뀜
	auto bg = m_gameObjects["Background"s]->GetComponent<BackgroundComponent>();
	bg->SetCurrentBitmap("Background");

	// 키로 이미지 설정 하는 과정 "Sinclair + GameManager::Get().curGen" = Sinclair3? 2? 4?
	auto ch = m_gameObjects["Character"s]->GetComponent<BackgroundComponent>();
	std::string result = "Sinclair";
	result += std::to_string(GameManager::Get().curGen/*얘가 세대를 나타내는 숫자임*/);
	ch->SetCurrentBitmap(result);
}

void Scene_Outgame::ChangeState(State newState)
{
	m_state = newState;


	// 버튼 콜백을 가져오기 위한 준비
	auto yesButton = m_gameObjects["아웃게임4"]->GetComponent<ButtonComponent>();
	auto noButton = m_gameObjects["아웃게임5"]->GetComponent<ButtonComponent>();
	// '다음' 또는 선택지 버튼들도 마찬가지로 가져옵니다.

	switch (m_state)
	{
	case FIRST_ENTER:
	{
		curText = getRandomText();

		// '다음' 버튼을 보여주고 '예' 버튼은 숨깁니다.
		yesButton->m_isInvisible = true;
		noButton->SetCurrentBitmap("next");

		// '다음' 버튼의 콜백을 설정하여, 다음 텍스트를 보여주거나 상태를 80002로 변경하도록 합니다.
		noButton->SetOnClickCallback([this]() {
			ChangeState(CHOICE_MENU);
		});
		break;
}

	case CHOICE_MENU: // 분리할 수도 있음
	{
		curText = outGameTextTable.find(m_state)->second; 
		// "> 창고로 이동한다.\n> 모험을 떠난다."
		// '창고', '모험' 버튼을 보여주고 콜백을 설정해야 합니다.
		// 현재는 '예/아니오' 버튼만 있으므로, 이들을 재활용하거나 새로 만들어야 합니다.
		// 예시: '예' 버튼을 '창고' 버튼으로 사용
		// 투명 버튼 어려움!
		// 비활성화도 어려움
		yesButton->m_isInvisible = false;
		noButton->SetCurrentBitmap("no");

		yesButton->SetOnClickCallback([this]() {
			// 3, 4세대는 모험을 떠날 수 없다는 등의 조건은 여기서 GameManager::Get().curGen으로 확인 가능
			ChangeState(ENTER_OUTGAME);
			});

		// 예시: '아니오' 버튼을 '모험' 버튼으로 사용
		noButton->SetOnClickCallback([this]() {
			ChangeState(ENTER_END);
			});
		break;
	}

	case ENTER_OUTGAME:
	{
		curText = outGameTextTable.find(m_state)->second; // "창고에 들어가시겠습니까?..."



		yesButton->SetOnClickCallback([this]() {
			cout << "창고에 들어가시겠습니까?..." << endl;
			SceneManager::Get().ChangeScene("InGame");
			});

		noButton->SetOnClickCallback([this]() {
			ChangeState(CHOICE_MENU); // 선택지로 돌아가기
			});
		break;
	}

	case ENTER_END:
	{
		curText = outGameTextTable.find(m_state)->second; // "여행을 떠나시겠습니까?..."


		yesButton->SetOnClickCallback([this]() {
			cout << "여행을 떠나시겠습니까?..." << endl;
			SceneManager::Get().ChangeScene("End");
			});

		noButton->SetOnClickCallback([this]() {
			ChangeState(CHOICE_MENU); // 선택지로 돌아가기
			});
		break;
	}
	}
}

